<?php

// Строковые функции PHP - работа с регистром символов

include "functions.php";

/* 
Изучите теорию по следующим ссылкам:
strtolower - преобразует строку в нижний регистр 
strtoupper - преобразует строку в верхний регистр - только символы латиницы
ucfirst - преобразует к верхнему регистру первый символ (латиница 1 байтовые символы)
lcfirst - первый символ в нижний регистр
ucwords - первый символ каждого слова в верхний регистр 
*/

// №1⊗ppPmIBSt
// Дана строка 'php'. Сделайте из нее строку 'PHP'.
task(1);
echo strtoupper("php");
// №2⊗ppPmIBSt
// Дана строка 'PHP'. Сделайте из нее строку 'php'.
task(2);
echo strtolower("PHP");
// №3⊗ppPmIBSt
// Дана строка 'london'. Сделайте из нее строку 'London'.
task(3);
echo ucfirst("london");
// №4⊗ppPmIBSt
// Дана строка 'London'. Сделайте из нее строку 'london'.
task(4);
echo lcfirst('London');
// №5⊗ppPmIBSt
// Дана строка 'london is the capital of great britain'. 
// Сделайте из нее строку 'London Is The Capital Of Great Britain'.
task(5);
echo ucwords("london is the capital of great britain");
// №6⊗ppPmIBSt
// Дана строка 'LONDON'. Сделайте из нее строку 'London'.
task(6);
echo strtolower("LONDON");

// Работа с strlen
// Изучите теорию по следующим ссылкам:
// strlen - возвращает длину строки


// №7⊗ppPmIBSt
// Дана строка 'html css php'. 
//Найдите количество символов в этой строке.
task(7);
echo strlen('html css php');

// №8⊗ppPmIBSt
// Дана переменная $password, в которой хранится пароль
// пользователя. Если количество символов пароля больше 5-ти
// и меньше 10-ти, то выведите пользователю сообщение о том, 
// что пароль подходит, иначе сообщение о том, что нужно
// придумать другой пароль.
$password = "1256";
if (strlen($password) > 5 and strlen($password) < 10) {
    echo "Пароль подходит";
} else echo "Нужно придумать новый пароль";


// Работа с substr
// Изучите теорию по следующим ссылкам:
// substr


/* Функция substr вырезает и возвращает подстроку из строки. 
Сама строка при этом не изменяется. Первым параметром функция 
принимает строку, вторым позицию символа, откуда нада начать
вырезание, а третьим - количество символов. Нумерация символов 
начинается с нуля. Второй параметр может быть отрицательным - 
тогда вырезка начнётся с конца.

Второй параметр может быть отрицательным - в этом случае отсчёт 
начинается с конца строки.

Третий параметр - если не указать произойдет обрезка до 
конца строки. 

Функция корректна только с символами латиницы (однобайтовыми).
*/

// №9⊗ppPmIBSt
// Дана строка 'html css php'. 
// Вырежьте из нее и выведите на экран слово
// 'html', слово 'css' и слово 'php'.
task(9);
$str = 'html css php';
$html = substr($str, 0, 4);
echo $html . "\n";
echo substr($str, 5, 3) . "\n";
echo substr($str, -3);
// №10⊗ppPmIBSt
// Дана строка. Вырежьте и выведите на экран последние 3 символа этой строки.
$str = "112345000";
task(10);
echo substr($str, -3);
// №11⊗ppPmIBSt
// Дана строка. Проверьте, что она начинается на 'http://'.
task(11);
$str = "http://ya.ru";
if (substr($str, 0, 7) == "http://") {
    echo "Строка начинается на http://";
}

// №12⊗ppPmIBSt
// Дана строка. Проверьте, что она начинается на 'http://' или на 'https://'.
task(12);
$str = "http://ya.ru";
if (substr($str, 0, 7) == "http://" or substr($str, 8, 8) == "https://") {
    echo "Строка начинается на http:// или на https://";
}
// №13⊗ppPmIBSt
// Дана строка. Проверьте, что она заканчивается на '.png'.
task(13);
$str = "img.png";
if (substr($str, -4) === '.png') {
    echo "Файл имеет формат .png";
}

// №14⊗ppPmIBSt
// Дана строка. Проверьте, что она заканчивается на '.png' или на '.jpg'.
$str = "img.png";
if (substr($str, -4) === '.jpg' or substr($str, -4) === '.png') {
    echo "Файл имеет формат .png или .jpg";
}


// №15⊗ppPmIBSt
// Дана строка. Если в этой строке более 5-ти символов - 
// вырежьте из нее первые 5 символов,
// добавьте троеточие в конец и выведите на экран.
//  Если же в этой строке 5 и менее символов - 
//  просто выведите эту строку на экран.
task(15);
$str = "1234567890";
if (strlen($str) > 5) {
    $newString = substr($str, 0, 5) . "...";
    echo $newString;
} else {
    echo $str;
}






// Работа с str_replace
// Изучите теорию по следующим ссылкам:
// str_replace
// №16⊗ppPmIBSt
// Дана строка '31.12.2013'. Замените все точки на дефисы.
task(16);
$strDate = '31.12.2013';
echo str_replace('.', '-', $strDate);

// №17⊗ppPmIBSt
// Дана строка. Замените в ней все буквы 'a' на цифру 1, буквы 'b' - на 2, а буквы 'c' - на 3.
task(17);
$str = 'abcdefgydl';
echo str_replace(['a', 'b', 'c'], [1, 2, 3], $str);


// №18⊗ppPmIBSt
// Дана строка с буквами и цифрами, например, 
// '1a2b3c4b5d6e7f8g9h0'. 
// Удалите из нее все цифры. 
// То есть в нашем случае должна получится строка 'abcbdefgh'.
task(18);
$str = '1a2b3c4b5d6e7f8g9h0';
echo str_replace(
    ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    [""],
    $str
);


// Работа с strtr
// Изучите теорию по следующим ссылкам:
// strtr

/* Функция strstr осуществляет поиск и замену символов в строке
имеет два варианта работы 

в первом варианте функция принимает массив замен, ключами служит 
то, что мы меняем - а значениями на что будем менять

strstr(где меняем, массив замен)

Во втором варианте функция одним параметром принимает строку где 
будет производится замена

strstr(где меняем, что меняем, на что меняем)
*/

// №19⊗ppPmIBSt
// Дана строка $str. Замените в ней все 'a' на цифру 1, 
// буквы 'b' - на 2, 
// а буквы 'c' - на 3. 
// Решите задачу двумя способами работы с функцией
//  strtr (массив замен и две строки замен).

task(19);
$str = 'abcdef';
$arrReplace = [
    'a' => '1',
    'b' => '2',
    'c' => '3'
];
echo strtr($str, $arrReplace);
echo strtr($str, "abc", "123");

// Работа с substr_replace
// Изучите теорию по следующим ссылкам:
// substr_replace - заменяет указанную часть строки на другую 


// №20⊗ppPmIBSt
// Дана строка $str. Вырежьте из нее подстроку 
// с 3-го символа (отсчет с нуля), 5 штук и вместо нее вставьте '!!!'.
task(20);
$str = "1234567890120";
echo substr_replace($str, "!!!", 3, 5);
// Работа с strpos, strrpos
// Изучите теорию по следующим ссылкам:
// strpos - возвращает позицию первого вхождения подстроки в другую строку
// strrpos - возвращает позицию последнего вхождения продстроки
// №21⊗ppPmIBSt
// Дана строка 'abc abc abc'.
//  Определите позицию первой буквы 'b'.
task(21);
$str = 'abc abc abc';
echo "Индекс первого вхождения символа b:" . strpos($str, 'b');
// №22⊗ppPmIBSt
// Дана строка 'abc abc abc'. 
// Определите позицию последней буквы 'b'.
task(22);
echo "Позиция последней буквы b: " . strrpos($str, 'b');
// №23⊗ppPmIBSt
// Дана строка 'abc abc abc'. Определите позицию первой 
// буквы 'b', если начать поиск не с начала строки, а с позиции 3.
task(24);
echo strpos($str, 'b', 3);
// №24⊗ppPmIBSt
// Дана строка 'aaa aaa aaa aaa aaa'. Определите позицию второго пробела.
task(25);
$indexFirstSpace = strpos($str, " ");
echo "Индекс первого пробела: " . $indexFirstSpace . "\n";
$indexSecondSpace = strpos($str, ' ', $indexFirstSpace + 1);
echo "Индекс второго пробела: " . $indexSecondSpace;
// №25⊗ppPmIBSt
task(25);
// Проверьте, что в строке есть две точки подряд.
$str = '123..123';
if (strpos($str, "..") != false) {
    echo "В строке есть две точки подряд";
} else echo "Нет двух точек подряд!";

// №26⊗ppPmIBSt
// Проверьте, что строка начинается на 'http://'.
task(26);
$str = "htp://ya.ru";
if (strpos($str, "http://ya.ru") === 0) {
    echo "Строка начинается с http://";
} else {
    echo "Строка начинается с чего-то другого";
}


// Работа с explode, implode
// Изучите теорию по следующим ссылкам:
// explode - разбивает строку в массив по определённому разделителю
// explode(разделитель, строка)
// implode(разделитель, массив) - сливает строку в массив с указанным разделителем

// №27⊗ppPmIBSt
// Дана строка 'html css php'. Запишите каждое слово этой строки в отдельный элемент массива.
task(27);
$arr = explode(" ", "html css php");
print_r($arr);

// №28⊗ppPmIBSt
// Дан массив с элементами 'html', 'css', 'php'. 
//С помощью implode создайте строку из этих элементов, разделенных запятыми.
task(28);
$arr = ['html', 'css', 'php'];
$str = implode(",", $arr);
echo $str;


// №29⊗ppPmIBSt
// В переменной $date лежит дата в формате год-месяц-день. 
//Преобразуйте эту дату в формат день.месяц.год.
task(29);
$str = "2025-12-10";
$newStr = implode(".", explode("-", $str));
echo $newStr;


// Работа с str_split
// Изучите теорию по следующим ссылкам:
// str_split



/* str_split - разбивает строку в массив, 
первым параметром принимает строку - вторым количество символов в элементе

*/


// №30⊗ppPmIBSt
// Дана строка '1234567890'. Разбейте ее на массив с элементами '12', '34', '56', '78', '90'.
task(30);
$str = '1234567890';
print_r(str_split($str, 2));

// №31⊗ppPmIBSt
// Дана строка '1234567890'. Разбейте ее на массив с элементами '1', '2', '3', '4', '5', '6', '7', '8', '9', '0'.
task(31);
print_r(str_split($str, 1));

// №32⊗ppPmIBSt
// Дана строка '1234567890'. Сделайте из нее строку '12-34-56-78-90' не используя цикл.
$arr = str_split($str, 2);
$newStr = implode("-", $arr);
echo $newStr;


// Работа с trim, ltrim, rtrim
// Изучите теорию по следующим ссылкам:
// trim ltrim rtrim

/* 
Функция trim(строка, "символы") удаляет пробелы с начала и конца строки. 
может также удалять другие символы, если указать их вторым параметром. 

ltrim удаляет пробелы сначала строки, может удалять другие символы, если их указать вторым параметром 
rtrim 
*/


// №33⊗ppPmIBSt
// Дана строка. Очистите ее от концевых пробелов.
task(33);
$str = "   1234   ";
echo trim($str);
// №34⊗ppPmIBSt
// Дана строка '/php/'. Сделайте из нее строку 'php', удалив концевые слеши.
task(34);
$str = '/php/';
echo trim($str, '/');
// №35⊗ppPmIBSt
// Дана строка 'слова слова слова.'. 
//В конце этой строки может быть точка, а может и не быть. Сделайте так, чтобы в конце этой строки гарантировано стояла точка. То есть: если этой точки нет - ее надо добавить, а если есть - ничего не делать. Задачу решите через rtrim без всяких ифов.
task(35);
// удаляем rtrim затем добавляем 
$str = 'слова слова слова.';
$str = rtrim($str, "."); // точку удалили если была 
$str .= "."; // гарантированно добавили 
echo $str;


// Работа с strrev
// Изучите теорию по следующим ссылкам:
// strrev - реверс символов



// №36⊗ppPmIBSt
// Дана строка '12345'. Сделайте из нее строку '54321'.
task(36);
$str = "12345";
$str = strrev($str);
echo $str;


// №37⊗ppPmIBSt
// Проверьте, является ли слово палиндромом (одинаково
// читается во всех направлениях, примеры таких слов: madam,
// otto, kayak, nun, level).
task(37);

function isPalindrome($str)
{
    if ($str == strrev($str)) {
        echo "$str - слово-палиндром\n";
    } else {
        echo "$str - не является словом палиндромом\n";
    }
}

isPalindrome("madam");
isPalindrome("level");
isPalindrome("123");



// Работа с str_shuffle
// Изучите теорию по следующим ссылкам:
// str_shuffle - представляет символы в случайном порядке (корректно только с латиницей)


// №38⊗ppPmIBSt
// Дана строка. 
//Перемешайте символы этой строки в случайном порядке.
task(39);
$str = '1234567890';
echo str_shuffle($str);

// №39⊗ppPmIBSt
// Создайте строку из 6-ти случайных маленьких латинских букв так,
//  чтобы буквы не повторялись. 
//  Нужно сделать так, чтобы в нашей строке могла быть
//   любая латинская буква, а не ограниченный набор.
task(39);
$littleLatinLetters = "qwertyuiopasdfghjklzxcvbnm";
$randomString = str_shuffle($littleLatinLetters);
$arrString = str_split($randomString, 6);
echo $arrString[0];

// Работа с number_format
// Изучите теорию по следующим ссылкам:
// number_format
// №40⊗ppPmIBSt
// Дана строка '12345678'. Сделайте из нее строку '12 345 678'.
task(40);
$str = '12345678';
echo number_format($str, 0, '.', " ");

// Работа с str_repeat
// Изучите теорию по следующим ссылкам:
// str_repeat - повторяет строку заданное число раз



// №41⊗ppPmIBSt
// С помощью одного цикла и функции str_repeat выведите на экран следующую пирамидку:
task(41);
// x
// xx
// xxx
// xxxx
// xxxxx
// xxxxxx
// xxxxxxx
// xxxxxxxx
// xxxxxxxxx
$str = 'x';
for ($i = 1; $i <= 9; $i++) {
    echo str_repeat('x', $i) . "\n";
}

// №42⊗ppPmIBSt
// С помощью одного цикла и функции str_repeat выведите на экран следующую пирамидку:

// 1
// 22
// 333
// 4444
// 55555
// 666666
// 7777777
// 88888888
// 999999999

task(42);
for ($i = 1; $i <= 9; $i++) {
    echo str_repeat((string)$i, $i) . "\n";
}

// Работа с strip_tags и htmlspecialchars
// Изучите теорию по следующим ссылкам:
// htmlspecialchars strip_tags

/* 

Функция strip_tags удаляет html-теги из строки, не теряя их 
содержимого, вторым необязательным параметром можно указать разрешённые 
теги. Разрешённые теги указываются вместе с уголками

strip_tags(строка, [разрешённые теги])

Функция htmlspecialchars позволяет вывести теги в браузер так, чтобы 
он не считал их командами, а выводил как строки. 
Функция преобразует амерсанд & d &aml, угловую скобку &lt; 

если нужно преобразовать все html-сущности можно использовать 
htmlentities

*/


// №43⊗ppPmIBSt
// Дана строка 'html, <b>php</b>, js'. 
// Удалите теги из этой строки.
task(43);
$str = 'html, <b>php</b>, js';
echo strip_tags($str);

// №44⊗ppPmIBSt
// Дана строка $str. Удалите все теги из этой строки, кроме тегов <b> и <i>.
$str = '<div><strong>html</strong>, <b>php</b>, <i>js</i></div>';
task(44);
echo strip_tags($str, "<b><i>");

// №45⊗ppPmIBSt
// Дана строка 'html, <b>php</b>, js'. Выведите ее на экран 'как есть': то есть браузер не должен преобразовать <b> в жирный.
$str = 'html, <b>php</b>, js';
echo htmlspecialchars($str);


// Работа с chr и ord
// Изучите теорию по следующим ссылкам:
// chr ord

/* 
chr(код символа) - находим символ по его ASCII коду 
ord(символ) - возвращает код символа
*/

// №46⊗ppPmIBSt
// Узнайте код символов 'a', 'b', 'c', пробела.
task(46);

// №47⊗ppPmIBSt
// Изучите таблицу ASCII Определите границы,
// в которых располагаются буквы английского алфавита.

task(47);
echo "ASCII таблица";
for ($i = 0; $i < 255; $i++) {
    echo "code: $i - Symbol: " . chr($i) . "\n";
}

// a -97 z -122 A - 65; 90 - Z 

// №48⊗ppPmIBSt
// Выведите на экран символ с кодом 33.
task(48);
echo chr(33);
// №49⊗ppPmIBSt
// Запишите в переменную $str случайный символ - большую букву латинского алфавита. 
// Для этого с помощью таблицы ASCII определите какие целые числа соответствуют большим буквам латинского алфавита.
task(49);
$str = chr(rand(65, 90));
echo $str;

// №50⊗ppPmIBSt
// Запишите в переменную $str случайную строку $len длиной, состоящую из маленьких букв латинского алфавита.
task(50);
$len = 5;
$str = '';
for ($i = 0; $i < $len; $i++) {
    $str .= chr(rand(97, 122));
}
echo $str;


// №51⊗ppPmIBSt
// Дана буква английского алфавита. 
// Узнайте, она маленькая или большая.

task(51);

function isUpOrLowerCase($str)
{
    if (ord($str) >= 97 and ord($str) <= 122) {
        echo "$str - буква в нижнем регистре\n";
    } elseif (ord($str) >= 65 and ord($str) <= 90) {
        echo "$str - буква в верхнем регистре\n";
    } else {
        echo "$str - символ не является буквой\n";
    }
}

isUpOrLowerCase('A');
isUpOrLowerCase('a');
isUpOrLowerCase("h");
isUpOrLowerCase("J");
isUpOrLowerCase("0");
// Работа с strchr, strrchr
// Изучите теорию по следующим ссылкам:
// strchr strrchr

/* 
Функция strchr находит первое вхождение подстроки в строку 
и возвращает часть строки начиная с этого места до конца. 
если второй параметр состоит более чем из одного символа 
используется только первый символ

strchr(где ищем, что ищем)

strrchr - последнее вхождение символа в строку и возвращает подстроку 
с этого места до конца строки
*/
// №52⊗ppPmIBSt
// Дана строка 'ab-cd-ef'. С
// помощью функции strchr выведите на экран строку '-cd-ef'.
task(52);
$str = 'ab-cd-ef';
echo strchr($str, "-");
// №53⊗ppPmIBSt
// Дана строка 'ab-cd-ef'. С помощью функции strrchr выведите на экран строку '-ef'.
task(53);
echo strrchr($str, "-");

// Работа с strstr
// Изучите теорию по следующим ссылкам:
// strstr
// №54⊗ppPmIBSt
// Дана строка 'ab--cd--ef'. 
//С помощью функции strstr выведите на экран строку '--cd--ef'.
task(54);
$str = 'ab--cd--ef';
echo strstr($str, "--");
